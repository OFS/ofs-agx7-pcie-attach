//Copyright (C) 2021 Intel Corporation
//SPDX-License-Identifier: MIT
//===============================================================================================================
/**
 * Abstract:
 * class he_mem_user_intr_seq is executed by he_mem_user_intr_test 
 * 
 * This sequence verifies the functionality of the user interrupts  
 * The interrupt is generated by forcing / writing the error register 
 * PBA mechanism is verified using masking and un-masking the interrupt vector
 * Sequence is running on virtual_sequencer 
 *
 *
**/
//===============================================================================================================

`ifndef HE_MEM_USER_INTR_SEQ_SVH
`define HE_MEM_USER_INTR_SEQ_SVH

class he_mem_user_intr_seq extends base_seq;
    `uvm_object_utils(he_mem_user_intr_seq)
    `uvm_declare_p_sequencer(virtual_sequencer)

    he_lpbk_seq lpbk_seq;
    rand int loop;

    constraint loop_c { soft loop inside {1}; }

    function new(string name = "he_mem_user_intr_seq");
        super.new(name);
    endfunction : new

    task body();
        super.body();
	`uvm_info(get_name(), "Entering he_mem_user_intr_seq ...", UVM_LOW)
	`uvm_info(get_name(), $psprintf("loop=%0d",loop), UVM_LOW)
	for(int i = 0; i < loop; i++) begin
	    `uvm_do_on_with(lpbk_seq, p_sequencer, {
	        mode inside {3'b000, 3'b001, 3'b010, 3'b011};
		bypass_config_seq == 1;                 
		en_msix_chk == 1;
		he_mem == 1;
	    })
	    mmio_write64(.addr_(tb_cfg0.HE_MEM_BASE+'h138), .data_(64'h0));
	    #100ns;
	    mmio_write64(.addr_(tb_cfg0.HE_MEM_BASE+'h138), .data_(64'h1));
	end
	`uvm_info(get_name(), "Exiting he_mem_user_intr_seq...", UVM_LOW)
    endtask : body

endclass : he_mem_user_intr_seq

`endif // HE_MEM_USER_INTR_SEQ_SVH
