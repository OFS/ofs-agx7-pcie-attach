#!/usr/bin/env python3
# Copyright (C) 2022-2023 Intel Corporation
# SPDX-License-Identifier: MIT

#------------------------------------------------------------------------------------------------------
# This Python script generates the PFVF definition package for the OFS AXI-S BFM.
# The files generated are:
#    * pfvf_def_pkg_host.sv      >>> PFVF types and associative array for PF/VF access handling.
#    * gen_pfvf_def_pkg.log >>> A log file providing information about the generated packages.
#
# The PF/VF information used by this script is derived from the ".vh" include file generated by
# the qsys-script, pcie_ss_get_cfg.tcl:
#    $OFS_ROOTDIR/sim/scripts/qip_gen_n6001/syn/board/n6001/syn_top/ofs_ip_cfg_db/ofs_ip_cfg_pcie_ss.vh
#        
# This include file should contain the number of required PFs for OFS as well as the number and 
# association of the VFs.  This script utilizes two of the defines in the above file to configure
# the PF/VF configuration.  Here is an excerpt of the lines used at ~ line 47:
#    // Vector indicating enabled PFs (1 if enabled) with
#    // index range 0 to OFS_FIM_IP_CFG_PCIE_SS_MAX_PF_NUM
#    `define OFS_FIM_IP_CFG_PCIE_SS_PF_ENABLED_VEC 1, 1, 1, 1, 1
#    // Vector with the number of VFs indexed by PF
#    `define OFS_FIM_IP_CFG_PCIE_SS_NUM_VFS_VEC 3, 0, 0, 0, 0
#------------------------------------------------------------------------------------------------------

import argparse
import subprocess
import logging
import time
import datetime
import re
import sys
import os


#----------------------------------------------------------------
# The following function obtains the $OFS_ROOTDIR setting from
# the shell to orient the script.  If this environment variable
# is not set, then the script uses the git top-level directory 
# and navigates to where $OFS_ROOTDIR should be.
#----------------------------------------------------------------
def get_rootdir():
    rootdir = os.getenv('OFS_ROOTDIR')
    if rootdir is None:
        rootdir_pattern_found = 0
        rootdir = ""
        rootdir_pattern = r'(/\S*)'
        rootdir_cmd = subprocess.Popen(['git', 'rev-parse', '--show-toplevel'], stdout=subprocess.PIPE, bufsize=1, universal_newlines=True)
        with rootdir_cmd.stdout:
            for line in iter(rootdir_cmd.stdout.readline, ""):
                line_contains_pattern = re.search(rootdir_pattern, line)
                if (line_contains_pattern):
                    rootdir = line_contains_pattern.group(1) + "/" + "n6001@commit"
                    rootdir_pattern_found = 1
        rootdir_cmd.wait()
        command_success = rootdir_cmd.poll()
        if (command_success == 0):
            if (rootdir_pattern_found):
                logger.debug(f"Git root directory search has returned successfully with return value {command_success}.")
                logger.debug(f"Git root directory is: {rootdir}.")
            else:
                logger.error(f"ERROR: Git root directory returned is not in an absolute format.")
                logger.error(f"       Script {os.path.basename(__file__)} execution has been halted.")
                sys.exit(1)
        else:
            logger.error(f"ERROR: Git root directory search has failed.")
            logger.error(f"       Script {os.path.basename(__file__)} execution has been halted.")
            sys.exit(1)

    simdir = os.path.join(rootdir, 'sim')
    if not os.path.isdir(simdir):
        logger.error(f"ERROR: {simdir}/ directory not found. Check OFS_ROOTDIR environment varable.")
        logger.error(f"       Script {os.path.basename(__file__)} execution has been halted.") 
        sys.exit(1)
    return rootdir


#----------------------------------------------------------------
# The following function sets up the configuration file name for
# n6001 and f2000x projects.  Otherwise, it exits gracefully, 
# skipping the package generation.
#----------------------------------------------------------------
def get_config_file(host_or_soc):
    if (host_or_soc.upper() == 'SOC'):
        config_file_name = "ofs_ip_cfg_soc_pcie_ss.vh"
    else:
        config_file_name = "ofs_ip_cfg_pcie_ss.vh"
    board_path = f"{rootdir}/sim/scripts/qip_gen/quartus_proj_dir/ofs_ip_cfg_db"
    config_file = board_path + "/" + config_file_name
    if (not(os.path.isfile(config_file))):
        if (host_or_soc == 'SOC'):
            config_file_name = "ofs_ip_cfg_pcie_ss.vh"
            config_file = board_path + "/" + config_file_name
        else:
            logger.info(f">>> Warning: Failed to find configuration file {config_file}.")
            logger.info(f">>> If this build does not have a configuration file, then this is okay and PF/VF definition generation will be skipped.")
            sys.exit(0)
    return config_file



#----------------------------------------------------------------
# The following function fetches the latest git commit of the 
# local repo for documentation purposes.
#----------------------------------------------------------------
def get_last_commit():
    commit_pattern_found = 0
    commit = ""
    commit_pattern = r'commit\s*(\w+)'
    commit_cmd = subprocess.Popen(['git', 'log', '-n', '1'], stdout=subprocess.PIPE, bufsize=1, universal_newlines=True)
    with commit_cmd.stdout:
        for line in iter(commit_cmd.stdout.readline, ""):
            line_contains_pattern = re.search(commit_pattern, line)
            if (line_contains_pattern):
                commit = line_contains_pattern.group(1)
                commit_pattern_found = 1
    commit_cmd.wait()
    command_success = commit_cmd.poll()
    if (command_success == 0):
        if (commit_pattern_found):
            logger.debug(f"Git repo last commit search has returned successfully with return value {command_success}.")
            logger.debug(f"Git repo last commit is: {commit}.")
        else:
            logger.error(f"ERROR: Git repo last commit could not be found.") 
            logger.error(f"       Script {os.path.basename(__file__)} execution has been halted.") 
            sys.exit(1)
    else:
        logger.error(f"ERROR: Git Log command has failed.")
        logger.error(f"       Script {os.path.basename(__file__)} execution has been halted.") 
        sys.exit(1)
    return commit


#----------------------------------------------------------------
# The following function does the work of extracting the PF and 
# VF information from the SystemVerilog include file.
#----------------------------------------------------------------
def extract_vectors(host_or_soc):
    if (host_or_soc.upper() == 'SOC'):
        pf_vec_pattern = r'OFS_FIM_IP_CFG_SOC_PCIE_SS_PF_ENABLED_VEC\s+((\d(,)*\s*)+)'
        vf_vec_pattern = r'OFS_FIM_IP_CFG_SOC_PCIE_SS_NUM_VFS_VEC\s+((\d(,)*\s*)+)'
    else:
        pf_vec_pattern = r'OFS_FIM_IP_CFG_PCIE_SS_PF_ENABLED_VEC\s+((\d(,)*\s*)+)'
        vf_vec_pattern = r'OFS_FIM_IP_CFG_PCIE_SS_NUM_VFS_VEC\s+((\d(,)*\s*)+)'
    try:
        with open(config_file) as file_object:
            for line in file_object:
                line_contains_pf_pattern = re.search(pf_vec_pattern,line)
                if (line_contains_pf_pattern):
                    pf_vec_string = line_contains_pf_pattern.group(1)
                    pf_vec_string = pf_vec_string.rstrip()
                    pf_vec_string = pf_vec_string.replace(" ", "")
                    logger.info(f"pf_vec_string: >{pf_vec_string}<")
                line_contains_vf_pattern = re.search(vf_vec_pattern,line)
                if (line_contains_vf_pattern):
                    vf_vec_string = line_contains_vf_pattern.group(1)
                    vf_vec_string = vf_vec_string.rstrip()
                    vf_vec_string = vf_vec_string.replace(" ", "")
                    logger.info(f"vf_vec_string: >{vf_vec_string}<")
    except FileNotFoundError:
        logger.error(f">>> ERROR: Configuration File Not Found! .............: {config_file}")
        sys.exit(1)
    pf_enabled_list = pf_vec_string.split(",")
    num_vfs_per_pf = vf_vec_string.split(",")
    return pf_enabled_list,num_vfs_per_pf


#----------------------------------------------------------------
# The following function figures out if we are compileing for a 
# system with both HOST and SOC systems, like for f2000x, but may
# be extended to others as needed.
#----------------------------------------------------------------
def host_and_soc_needed():
    host_and_soc_pattern = r'f2000x'
    board_name_list = rootdir.split("/")
    board_name = board_name_list[-1]
    logger.info(f"Board Name Found: {board_name}")
    board_contains_host_and_soc_pattern = re.search(host_and_soc_pattern,board_name)
    if (board_contains_host_and_soc_pattern):
        logger.info(f"Search for Host-and-SOC Requirement was affirmative: {board_contains_host_and_soc_pattern}.")
        return True
    else:
        logger.info(f"Search for Host-and-SOC Requirement was negative: {board_contains_host_and_soc_pattern}.")
        return False


#----------------------------------------------------------------
# The following function is the one that does all the work of
# creating the PF/VF definition packages based on the 
# information in the generated include file.
#----------------------------------------------------------------
def generate_package(pf_enabled_list, num_vfs_per_pf, host_or_soc):
    target_upper_insert = '_' + host_or_soc.upper()
    target_lower_insert = '_' + host_or_soc.lower()
    banner = [   
            f"//\n",
            f"// Generated by OFS script {os.path.basename(__file__)}\n",
            f"//    Date/Time.........: {script_run_start}\n",
            f"//    Configuration File: {config_file}\n",
            f"\n" ]
    define_pfvf_header = [  
            f"`ifndef __PFVF_DEF_PKG{target_upper_insert}__\n",
            f"`define __PFVF_DEF_PKG{target_upper_insert}__\n",
            f"\n" ]
    package_pfvf_header = [  
            f"package pfvf_def_pkg{target_lower_insert};\n",
            f"\n" ]
    localparam_header = [
            f"//----------------------------------\n",
            f"// Parameter Definitions for Package\n",
            f"//----------------------------------\n",
            f"\n" ]
    package_pfvf_footer = [
            f"\n",
            f"endpackage: pfvf_def_pkg{target_lower_insert}\n" ]
    define_pfvf_footer = [
            f"\n",
            f"`endif // `ifndef __PFVF_DEF_PKG{target_upper_insert}__" ]
    file_out_pfvf_path = rootdir + "/sim/bfm/ofs_axis_bfm"
    file_out_pfvf_name = file_out_pfvf_path + "/" + f"pfvf_def_pkg{target_lower_insert}.sv"
    file_out_pfvf = open(file_out_pfvf_name, "w")
    file_out_pfvf.writelines(banner)
    file_out_pfvf.writelines(define_pfvf_header)
    file_out_pfvf.writelines(package_pfvf_header)
    file_out_pfvf.writelines(localparam_header)
    #---------------------------------------------------------------------
    # Here are the typedef and parameter definitions for the pfvf package
    #---------------------------------------------------------------------
    pf_vec_length = len(pf_enabled_list)
    pf_enabled_list_field = ','.join(pf_enabled_list)
    vf_vec_length = len(num_vfs_per_pf)
    vf_num_list_field = ','.join(num_vfs_per_pf)
    file_out_pfvf.write(f"   typedef bit PF_ENABLED{target_upper_insert}_VEC_T[{pf_vec_length}];\n")
    file_out_pfvf.write(f"   parameter   PF_ENABLED{target_upper_insert}_VEC_T PF_ENABLED{target_upper_insert}_VEC = '{{{pf_enabled_list_field}}};\n")
    file_out_pfvf.write("\n")
    file_out_pfvf.write(f"   typedef int PF_NUM_VFS{target_upper_insert}_VEC_T[{vf_vec_length}];\n")
    file_out_pfvf.write(f"   parameter   PF_NUM_VFS{target_upper_insert}_VEC_T PF_NUM_VFS{target_upper_insert}_VEC = '{{{vf_num_list_field}}};\n")
    file_out_pfvf.write("\n")
    #-------------------------------------------------------------
    # Here is the package footer
    #-------------------------------------------------------------
    file_out_pfvf.writelines(package_pfvf_footer)
    file_out_pfvf.writelines(define_pfvf_footer)
    file_out_pfvf.close()

if __name__ == '__main__':

    axi_st_addr_width = 64;
    pf_enabled_list = [];
    num_vfs_per_pf  = [];
    script_run_start = datetime.datetime.now()
    rootdir = get_rootdir()
    format = "%(asctime)s: %(message)s"
    tformat = "%Y-%m-%d %H:%M:%S"
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    formatter = logging.Formatter(format,tformat)
    stdout_handler = logging.StreamHandler(sys.stdout)
    stdout_handler.setLevel(logging.INFO)
    #stdout_handler.setLevel(logging.DEBUG)
    stdout_handler.setFormatter(formatter)
    log_file_name = rootdir + "/sim/bfm/ofs_axis_bfm" + "/" + "gen_pfvf_def_pkg.log"
    file_handler = logging.FileHandler(log_file_name)
    file_handler.setLevel(logging.INFO)
    #file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)
    logger.addHandler(stdout_handler)
    #config_file_path = rootdir + "/sim/bfm/ofs_axis_bfm"
    #---------------  HOST  --------------------------------
    config_file = get_config_file('HOST')
    script_dir = os.path.dirname(os.path.realpath(__file__))
    git_commit = get_last_commit()
    logger.info(f">>> Running PF/VF Definitions Package Generator Script: {os.path.basename(__file__)}")
    logger.info(f"    Run at Date/Time..................................: {script_run_start}")
    logger.info(f"    OFS Root Directory................................: {rootdir}")
    logger.info(f"    Git Repo Last Commit..............................: {git_commit}")
    logger.info(f"    Script Location...................................: {script_dir}")
    if (os.path.exists(config_file)):
        logger.info(f"    Configuration File................................: {config_file}")
    else:
        logger.error(f">>> ERROR: Configuration File Not Found! .............: {config_file}")
        sys.exit(1)
    pf_enabled_list,num_vfs_per_pf = extract_vectors('HOST')
    generate_package(pf_enabled_list, num_vfs_per_pf, 'HOST')
    #---------------  SoC  --------------------------------
    if (host_and_soc_needed()):
        config_file = get_config_file('SOC')
        logger.info(f">>> SOC Running PF/VF Definitions Package Generator Script: {os.path.basename(__file__)}")
        logger.info(f"    Run at Date/Time..................................: {script_run_start}")
        logger.info(f"    OFS Root Directory................................: {rootdir}")
        logger.info(f"    Git Repo Last Commit..............................: {git_commit}")
        logger.info(f"    Script Location...................................: {script_dir}")
        if (os.path.exists(config_file)):
            logger.info(f"    Configuration File................................: {config_file}")
        else:
            logger.error(f">>> ERROR: Configuration File Not Found! .............: {config_file}")
            sys.exit(1)
        pf_enabled_list,num_vfs_per_pf = extract_vectors('SOC')
        generate_package(pf_enabled_list, num_vfs_per_pf, 'SOC')
    else:
        # If HOST only, the SOC file is simply a copy of the HOST.
        config_file = get_config_file('HOST')
        logger.info(f">>> HOST Running PF/VF Definitions Package Generator Script: {os.path.basename(__file__)}")
        logger.info(f"    Run at Date/Time..................................: {script_run_start}")
        logger.info(f"    OFS Root Directory................................: {rootdir}")
        logger.info(f"    Git Repo Last Commit..............................: {git_commit}")
        logger.info(f"    Script Location...................................: {script_dir}")
        if (os.path.exists(config_file)):
            logger.info(f"    Configuration File................................: {config_file}")
        else:
            logger.error(f">>> ERROR: Configuration File Not Found! .............: {config_file}")
            sys.exit(1)
        pf_enabled_list,num_vfs_per_pf = extract_vectors('HOST')
        generate_package(pf_enabled_list, num_vfs_per_pf, 'SOC')
